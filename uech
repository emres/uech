#!/usr/bin/env bash

set -euo pipefail; [[ -z ${TRACE:-} ]] || set -x

if [[ ! $BASH_VERSION =~ ^4 ]]; then
	echo >&2 "Bash 4 required"
	exit 1
fi

# Program name
readonly PROGNAME=${0##*/}

# Version
readonly VERSION=0.0

Util() {
	# Primitive to display message on stderr
	cry() {
		echo -e >&2 "$*"
	}

	# Display error and exit
	die() {
		cry "$@"
		exit 1
	}

	# Signal a bug
	bug() {
		cry "BUG:   $*"
		cry "BUG:   Please report the issue."
		exit 128
	}

	# Prefix the line with the given string
	prefix() {
		sed "s/^/$1/"
	}

	# Standard indent filter
	indent() {
		sed 's/^/       /'
	}

	# Remove CR at EOL
	nocr() {
		sed "s/\r$//"
	}

	# Has the params from the second position contains the first param?
	has() {
		local needle=$1
		shift
		[[ " $* " =~ [[:space:]]$needle[[:space:]] ]]
	}

	# Join given parameters using the separator
	join() {
		local separator=$1
		shift
		echo "$(IFS="$separator"; echo "${*}")"
	}

	# Run by piping stdout and stderr
	piped() {
		local filter=$1
		shift
		if [[ -n $filter ]]; then
			{ "$@" 2>&1 1>&3 3>&- | "$filter"; } 3>&1 1>&2 | "$filter"
		else
			"$@"
		fi
	}
}

Ui() {
	# Color palette

	declare -Ag Palette=(
		[grey]=240
		[cyan]=14
		[red]=197
		[yellow]=11
	)

	palette.bold() {
		echo -en "\e[1;38;5;${Palette[$1]}m"
	}

	palette.normal() {
		echo -en "\e[38;5;${Palette[$1]}m"
	}

	palette.reset() {
		echo -en "\e[0m"
	}

	# UI colors

	declare -Ag Color=(
		[Local-]=yellow
		[Upload]=grey
		[Remote]=cyan
		[Download]=grey
		[Local+]=yellow
	)

	step.start() {
		local step=$1
		echo -e >&2 "$(palette.bold "${Color[$step]}")-----> ${step}$(palette.reset)$(palette.normal "${Color[$step]}")"
	}

	step.failed() {
		local step=$1
		local err=$2
		echo -e >&2 "$(palette.bold "red")-----> ${step} step failed with exit code:$(palette.reset) $err"
	}

	step.stop() {
		echo -e >&2 "$(palette.reset)"
	}

	# UI output filters

	declare -Ag Filter=(
		[Local-]=filter.default
		[Upload]=filter.default
		[Remote]=filter.remote
		[Download]=filter.default
		[Local+]=filter.default
	)

	filter.default() {
		indent
	}

	filter.remote() {
		# Remove CR at the EOL which is generated by "ssh -t" and indent
		nocr | indent
	}

	# UI action

	ui.do() {
		local step=$1
		shift

		step.start "$step"

		local err=
		piped "${Filter[$step]}" "$@" || err=$?
		[[ $err -eq 0 ]] || step.failed "$step" "$err"

		step.stop

		return $err
	}

	# Load this module

	ui.load() {
		if has quiet "$@"; then
			ui.do() {
				shift
				"$@"
			}
		fi

		if has nocolor "$@"; then
			local c
			for c in "${!Palette[@]}"; do
				Palette[$c]=
			done
		fi

		if has debug "$@"; then
			ui.debug() {
				{
					echo "$1"
					shift
					"$@"
				} | prefix "DEBUG: " >&2
			}
		else
			ui.debug() {
				:
			}
		fi
	}

	ui.load "$@"
}

# Self template for both sides (local and remote)
Self() {
	declare -ag Args=() # command line arguments vector

	# Main template (all functions defined at the relevant side)
	self.main() {
		Args=("$@")

		self.flags
		self.args

		self.init

		self.run "${Args[@]}"
	}

	# Initialize before run (overwritten by the current side)
	self.init() {
		super.init
	}

	# Shutdown after run (overwritten by the current side)
	self.shutdown() {
		super.shutdown
	}

	# Enter the working directory (so called the "center")
	self.enter() {
		pushd "${Self[center]}" >/dev/null || die "Cannot chdir: '${Self[center]}'"
	}

	# Leave the working directory
	self.leave() {
		popd >/dev/null
	}

	# Dump self
	self.puts() {
		local key
		for key in "${!Self[@]}"; do
			printf "%10s:  %s\n" "$key" "${Self[$key]}"
		done
	}

	# Base functions which should not be overwritten (hence super.)

	declare -ag Cleanup=()

	super.shutdown() {
		rm -rf -- "${Cleanup[@]}"
	}

	super.init() {
		# Setup UI

		local -a flags=()

		local flag
		for flag in nocolor quiet debug; do
			[[ -z ${Self[$flag]} ]] || flags+=("$flag")
		done

		Ui "${flags[@]}"

		# Register shutdown
		declare -g err

		trap '
			err=$?
			self.shutdown || true
			exit "$err"
		' EXIT HUP INT QUIT TERM
	}

	# Load this module

	self.load() {
		# Setup coreutils for Mac OS X
		if [[ $OSTYPE == darwin ]]; then
			export PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH"

			command -v greadlink >/dev/null || die "GNU coreutils required"
			alias readlink=greadlink

			command -v grealpath >/dev/null || die "GNU coreutils required"
			alias realpath=grealpath
		fi
	}

	self.load
}

# Remote side
Remote() {
	# Self object at the remote side
	declare -Ag Self=(
		[buffer]=""  # buffer directory
		[debug]=""   # debug mode?
		[exe]=""     # absolute path of the executable
		[keep]=""    # keep remote store?
		[local]=""   # local mode?
		[mono]=""    # run mono (i.e. only at remote)?
		[nocolor]="" # no color?
		[quiet]=""   # be quiet?
	)

	# Process options
	self.flags() {
		set -- "${Args[@]}"

		local arg
		while [[ $# -gt 0 ]]; do
			arg=$1

			case $arg in
			-local)
				Self[local]=true
				;;
			-keep)
				Self[keep]=true
				;;
			-mono)
				Self[mono]=true
				;;
			-nocolor)
				Self[nocolor]=true
				;;
			-debug)
				Self[debug]=true
				;;
			-quiet)
				Self[quiet]=true
				;;
			-*)
				bug "Unrecognized flag: $arg"
				;;
			*)
				break
				;;
			esac

			shift
		done

		Args=("$@")
	}

	# Process (non-flag) arguments
	self.args() {
		set -- "${Args[@]}"

		[[ $# -ge 1 ]] || bug "Missing arguments"

		local exe=$1
		shift

		[[ -f $exe ]] || bug "No such file: '$exe'"
		[[ -x $exe ]] || bug "Not an executable: '$exe'"
		[[ $exe != /* ]] || bug "Must be a relative path: '$exe'"

		# Convert the path of executable to an absolute path
		Self[exe]=$(readlink -f "$exe")

		Args=("$@")
	}

	# Post initialization after processing options and arguments
	self.init() {
		super.init

		# Calculate center
		Self[center]=${Self[exe]%/*}
	}

	# Shutdown procedure
	self.shutdown() {
		super.shutdown
	}

	# Run the executable
	self.run() {
		ui.debug "Remote" self.puts

		self.enter
		if [[ -z ${Self[mono]} ]]; then
			"${Self[exe]}" REMOTE "$@"
		else
			"${Self[exe]}" "$@"
		fi
		self.leave
	}

	usage() {
		cry "$PROGNAME [<flags>...] <executable> [<arguments>...]"
		exit "${1:-0}"
	}

	# Load this module

	self.load() {
		# Chdir to buffer directory at start
		local buffer=${UECH_REMOTE:?}

		[[ -d $buffer ]] || bug "No buffer directory found: '$buffer'"
		pushd "$buffer" >/dev/null || die "Cannot chdir to: '$buffer'"

		Self[buffer]=$buffer
	}

	self.load
}

# Local side
Local() {
	# Self object at the local side
	declare -Ag Self=(
		[buffer]=""  # buffer directory
		[center]=""  # absolute path of the working directory
		[clean]=""   # clean remote store before?
		[config]=""  # ssh config file
		[debug]=""   # debug mode?
		[exe]=""     # absolute path of the executable
		[git]=""     # treat as a Git repository?
		[host]=""    # ssh host
		[keep]=""    # keep remote store?
		[local]=""   # local mode?
		[mono]=""    # run mono (i.e. only at remote)?
		[nocolor]="" # no color?
		[noreuse]="" # no reuse ssh connection?
		[quiet]=""   # be quiet?
		[radius]=""  # radius from the working directory
	)

	declare -ag Remote=() # flags to transfer to the remote side

	# Process options
	self.flags() {
		set -- "${Args[@]}"

		local arg
		while [[ $# -gt 0 ]]; do
			arg=$1

			case $arg in
			-radius|-radius=*)
				local value
				case $arg in
				*=*)
					value=${arg#*=}
					;;
				*)
					shift
					value=${1:-}
					;;
				esac
				[[ -n $value ]] || die "Value required for flag: '-radius'"
				[[ $value =~ [0-9]+ ]] || die "Radius must be an integer: '$value'"

				Self[radius]=$value
				;;
			-git)
				Self[git]=true
				;;
			-buffer|-buffer=*)
				local value
				case $arg in
				*=*)
					value=${arg#*=}
					;;
				*)
					shift
					value=${1:-}
					;;
				esac
				[[ -n $value ]] || die "Value required for flag: '-buffer'"

				Self[buffer]=$value
				;;
			-keep)
				Self[keep]=true
				Remote+=("$arg")
				;;
			-config|-config=*)
				local value
				case $arg in
				*=*)
					value=${arg#*=}
					;;
				*)
					shift
					value=${1:-}
					;;
				esac
				[[ -n $value ]] || die "Value required for flag: '-config'"
				[[ -f $value ]] || die "No such file: '$value'"

				Self[config]=$(readlink -f "$value")
				;;
			-local)
				Self[local]=true
				Remote+=("$arg")
				;;
			-clean)
				Self[clean]=true
				;;
			-mono)
				Self[mono]=true
				Remote+=("$arg")
				;;
			-nocolor)
				Self[nocolor]=true
				Remote+=("$arg")
				;;
			-noreuse)
				Self[noreuse]=true
				;;
			-debug)
				Self[debug]=true
				Remote+=("$arg")
				;;
			-quiet)
				Self[quiet]=true
				Remote+=("$arg")
				;;
			-version)
				echo "$VERSION"
				exit 0
				;;
			-help)
				usage
				;;
			-*)
				die "Unrecognized flag: '$arg'"
				;;
			*)
				break
				;;
			esac

			shift
		done

		Args=("$@")
	}

	# Process (non-flag) arguments
	self.args() {
		set -- "${Args[@]}"

		[[ $# -ge 2 ]] || usage 2

		local host=$1
		shift

		[[ -n $host ]] || die "No host given"

		# Catch bogus hostname (e.g. file path as hostname)
		[[ ! $host =~ [/\\] ]] || die "Invalid host name"

		Self[host]=$host

		local exe=$1
		shift

		[[ -f $exe ]] || die "No such file: '$exe'"
		[[ -x $exe ]] || die "Not an executable: '$exe'"

		# Convert the path of executable to an absolute path
		Self[exe]=$(readlink -f "$exe")

		Args=("$@")
	}

	# Create buffer beforehand
	self.buffer() {
		local buffer=${Self[buffer]}

		if [[ -z $buffer ]]; then
			if [[ -z ${Self[local]} ]]; then
				buffer=$(
					ssh.run /bin/mktemp -d -t uech.XXXXXX
				)
			else
				buffer=$(/bin/mktemp -d -t uech.XXXXXX)
			fi
		else
			if [[ -z ${Self[local]} ]]; then
				buffer=$(
					ssh.run bash -e -s "$buffer" "${Self[clean]}" <<-'EOF'
						[[ -z "$2" ]] || rm -rf "${1:?}"
						mkdir -m 700 -p "$1"
						cd "$1"
						echo "$PWD"
					EOF
				)
			else
				[[ $buffer = /* ]] || buffer="$HOME/$buffer"
				[[ -z "${Self[clean]}" ]] || rm -rf "${buffer:?}"
				# shellcheck disable=2174
				mkdir -m 700 -p "$buffer"
			fi

		fi || die "Cannot create buffer directory"

		ui.debug "Buffer successfully created: $buffer"

		Self[buffer]=$buffer
	}

	# Setup flags affected from the presence of a Git repository
	self.gitflag() {
		self.enter

		local gitdir
		if gitdir=$(git rev-parse --show-toplevel 2>/dev/null); then
			# Sanity check
			if git check-ignore -q --no-index "${Self[exe]}"; then
				cry "Executable must be tracked, otherwise it won't be copied to remote."
				die "Git ignored executable: '${Self[exe]}'"
			fi
			# Set radius to the repository depth
			if [[ -z ${Self[radius]} ]]; then
				Self[radius]=$(radius "${Self[center]}" "$gitdir")
			fi
		else
			Self[git]=
		fi

		self.leave
	}

	# Post initialization after processing options and arguments
	self.init() {
		super.init

		# Calculate center
		Self[center]=${Self[exe]%/*}

		if [[ -n ${Self[clean]} ]] && [[ -z ${Self[buffer]} ]]; then
			die "Flag '-clean' must be used with '-buffer' flag"
		fi

		[[ -z ${Self[git]} ]] || self.gitflag

		[[ -n ${Self[radius]} ]] || Self[radius]=0

		if [[ -z ${Self[local]} ]]; then
			ssh.init
		fi

		self.buffer
	}

	# Shutdown before exit
	self.shutdown() {
		if [[ -z ${Self[keep]} ]]; then
			if [[ -z ${Self[local]} ]]; then
				ssh.run rm -rf "${Self[buffer]}"
			else
				rm -rf -- "${Self[buffer]}"
			fi
		fi

		if [[ -z ${Self[local]} ]] && [[ -z ${Self[noreuse]} ]]; then
			ssh.shutdown
		fi

		super.shutdown
	}

	# Invoke this program at the remote side
	self.remote() {
		self.enter

		local -a env=(
			# An indicator that we are on the remote side
			"UECH_REMOTE=${Self[buffer]}"
		)

		local periphery
		periphery=$(periphery "${Self[radius]}")

		# Convert executable path to a relative path
		local exe
		exe=$(realpath --relative-to="${periphery:-.}" "${Self[exe]}")

		local err=

		if [[ -z ${Self[local]} ]]; then
			local progfile
			progfile=$(ssh.run /bin/mktemp -t uech.XXXXXX) || die "mktemp error"

			ssh.run "cat >'$progfile'" <"$PROGFILE" || err=$?
			if [[ $err -eq 0 ]]; then
				ssh.run_with_tty env "${env[@]}" bash "$progfile" "${Remote[@]}" "$exe" "$@"  || err=$?
			else
				cry "Couldn't copy itself"
			fi

			ssh.run rm -f -- "$progfile" || true
		else
			env "${env[@]}" bash -s	-- "${Remote[@]}" "$exe" "$@" <"$PROGFILE"
		fi

		self.leave

		return $err
	}

	# Upload files (including the executable) inside the periphery to the remote side
	self.upload() {
		local src
		local dest

		local periphery
		periphery=$(periphery "${Self[radius]}")

		src=${periphery:-${Self[exe]}}

		if [[ -z ${Self[local]} ]]; then
			dest=${Self[host]}:${Self[buffer]}
		else
			dest=${Self[buffer]}
		fi

		rsync.run "$src" "$dest"
	}

	# Download files inside the periphery from the remote side
	self.download() {
		local src
		local dest

		# XXX: Watch for the trailing slash
		if [[ -z ${Self[local]} ]]; then
			src=${Self[host]}:${Self[buffer]}/
		else
			src=${Self[buffer]}/
		fi

		local periphery
		periphery=$(periphery "${Self[radius]}")

		dest=${periphery:-.}

		rsync.run "$src" "$dest"
	}

	# Run the executable
	self.run() {
		ui.debug "Local" self.puts

		self.enter

		[[ -n ${Self[mono]} ]] || ui.do Local- "${Self[exe]}" LOCAL- "$@"
		ui.do Upload self.upload
		ui.do Remote self.remote "$@"
		[[ ${Self[radius]} -eq 0 ]] || ui.do Download self.download # for radius zero, nothing to download
		[[ -n ${Self[mono]} ]] || ui.do Local+ "${Self[exe]}" LOCAL+ "$@"

		self.leave
	}

	# Wrap ssh

	declare -ag Ssh=() # argument vector which will be passed to SSH

	# Build SSH flags
	ssh.init() {
		super.init

		if [[ -n ${Self[config]} ]]; then
			Ssh+=(
				"-F"
				"${Self[config]}"
			)
		fi

		local host=${Self[host]}

		# Check if we have a composite hostname, e.g. user@host:port

		local name=$host
		name=${name##*@}; name=${name%%:*}

		if [[ $name != "$host" ]]; then
			if [[ $host =~ [@] ]]; then
				local user=${host%%@*}

				if [[ -z $user ]]; then
					die "Malformed user specification: '$host'"
				fi

				Ssh+=(
					"-l"
					"$user"
				)

			fi

			if [[ $host =~ [:] ]]; then
				local port=${host##*:}

				if [[ -z $port ]] || [[ ! $port =~ ^[0-9]+$ ]]; then
					die "Malformed port specification: '$host'"
				fi

				Ssh+=(
					"-p"
					"$port"
				)
			fi

			Self[host]=$name
		fi

		[[ -n ${Self[noreuse]} ]] || ssh.reuse
	}

	# Setup SSH to reuse connection
	ssh.reuse() {
		local tempdir

		tempdir=$(/bin/mktemp -d -t ssh.XXXXXX) || die "Error creating a temp directory"
		Cleanup+=("$tempdir")

		ui.debug "Initiating SSH"

		local ctrlpath="$tempdir/%r@%h:%p"

		# shellcheck disable=SC2029
		ssh "${Ssh[@]}" -n -N -f -o ControlMaster=yes -o ControlPath="$ctrlpath" "${Self[host]}"

		Ssh+=(
			"-o"
			"ControlPath=$ctrlpath"
		)

		# shellcheck disable=SC2029
		ssh "${Ssh[@]}" -q -O check "${Self[host]}" 2>/dev/null || die "SSH master check failed"
	}

	# Invoke SSH with the ssh flags and host
	ssh.run() {
		ui.debug "Invoking ssh: ${Ssh[*]} ${Self[host]} $*"
		# shellcheck disable=SC2029
		ssh "${Ssh[@]}" "${Self[host]}" "$@"
	}

	# Invoke SSH with pseudo-terminal allocation
	ssh.run_with_tty() {
		ui.debug "Invoking ssh: -t ${Ssh[*]} ${Self[host]} $*"
		# shellcheck disable=SC2029
		ssh -t -o LogLevel=QUIET "${Ssh[@]}" "${Self[host]}" "$@"
	}

	# Shutdown SSH connection
	ssh.shutdown() {
		# shellcheck disable=SC2029
		ssh "${Ssh[@]}" -q -O exit "${Self[host]}"
	}

	# Wrap rsync

	# Invoke Rsync with the self and SSH flags
	rsync.run() {
		local -a flags=(
			"-a" # archive mode
			"-z" # compress
		)
		if [[ -n ${Self[git]} ]]; then
			flags+=(
				"-C"                 # ignore .git
				"-f" ":- .gitignore" # ignore gitignored files
			)
		fi

		[[ -z ${Self[debug]} ]] || flags+=(
			"-P"
		)

		[[ -z ${Self[quiet]} ]] || flags+=(
			"-q"
		)

		if [[ ${#Ssh[@]} -gt 0 ]]; then
			flags+=(
				"-e"
				"ssh $(join ' ' "${Ssh[@]}")"
			)
		fi

		ui.debug "Invoking rsync: ${flags[*]} $*"
		rsync "${flags[@]}" "$@"
	}

	# Local helpers

	# Build relative parent directory using the radius value
	periphery() {
		local radius=$1

		# Radius 0
		[[ $radius -gt 0 ]] || return 0

		# Radius 1
		local -a path=(".")

		# Radius > 1
		for ((; radius > 1; radius--)); do
			path+=("..")
		done

		join '/' "${path[@]}"
	}

	# Calculate radius of periphery (a relative path) using the center (an absolute path)
	radius() {
		local center=$1
		local periphery=$2

		local -a parts
		IFS=$'/' read -ra parts <<<"$(realpath --relative-to="$center" "$periphery")"
		echo "$((${#parts[@]}+1))"
	}

	usage() {
		cry "$PROGNAME [<flags>...] [<user>@]<host>[:<port>] <executable> [<arguments>...]"
		cry "See $PROGNAME(1) for detailed information."
		exit "${1:-0}"
	}

	# Load this module

	self.load() {
		# Required programs at the local side
		command -v git &>/dev/null || die "Git required"
		command -v rsync &>/dev/null || die "Rsync required"

		# Check relative-to flag of realpath.  GNU coreutils version must be >= 8.23
		realpath --relative-to=. . &>/dev/null || die "GNU coreutils version 8.23 or higher required"

		# Save the absolute path where this program stored
		readonly PROGFILE=$(readlink -f "$(command -v "$0" 2>/dev/null || true)")
		[[ -n $PROGFILE ]] || bug "Cannot determine program file"
	}

	self.load
}

# Main entry
main() {
	# Load the modules

	Util

	Self

	if [[ -z ${UECH_REMOTE:-} ]]; then
		Local
	else
		Remote
	fi

	# Invoke
	self.main "$@"
}

if [[ "${BASH_SOURCE[0]:-}" == "$0" ]] || [[ -n ${UECH_REMOTE:-} ]]; then
	main "$@"
fi
